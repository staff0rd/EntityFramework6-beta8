// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.

namespace System.Data.Entity.Query
{
    using System.Linq;
    using System.Linq.Expressions;
    using System.Reflection;
    using Xunit;

    public class Codeplex2846Query : FunctionalTestBase
    {
        [Fact]
        public void Expressions_with_extra_convert_around_lambda_param_accepted()
        {
            Assert.DoesNotThrow(
                () =>
                {
                    using (var context = new BugContext())
                    {
                        var q = context.As.Where(new GenericService<A>().MakeExpressionWithExtraConvertExplicitly());
                        q.ToString();
                    }
                });
        }

        
        public class BugContext : DbContext
        {
            static BugContext()
            {
                Database.SetInitializer<BugContext>(null);
            }
            protected override void OnModelCreating(DbModelBuilder modelBuilder)
            {
                modelBuilder.Entity<A>()
                    .HasKey(x => x.Id);
            }

            public DbSet<A> As { get; set; }
        }

        public class A : Base
        {
            
        }

        public class Base
        {
            public int Id { get; set; }
        }

        private class GenericService<TType> where TType: Base
        {
            /// <summary>
            /// This method constructs an expression tree that explicitly matches the expression
            /// that would be generated by the MakeExpressionWithExtraConvertInRoslyn1_1 method
            /// but without relying on the compiler.
            /// </summary>
            /// <returns></returns>
            public Expression<Func<TType, bool>> MakeExpressionWithExtraConvertExplicitly()
            {
                var param = Expression.Parameter(typeof(TType), "u");
                var right = Expression.Constant(1);
                var left = Expression.MakeMemberAccess(Expression.Convert(param, typeof(Base)), typeof(TType).GetMember("Id")[0]);
                var body = Expression.Equal(left, right);
                var ex = Expression.Lambda<Func<TType, bool>>(body, param);
                Expression<Func<TType, bool>> e = ex;
                return e;
            }

            /// <summary>
            /// This method, when compiled with version 1.1 of the roslyn compiler will emit the
            /// expression e => Convert(e).Id which causes problems for the expression converter.
            /// This extra Convert will appear because the method uses a generic type as the lambda
            /// parameter which causes it to emit a Convert expression with the limit type (Base) as
            /// its type argument.
            /// </summary>
            /// <returns></returns>
            public Expression<Func<TType, bool>> MakeExpressionWithExtraConvertInRoslyn1_1()
            {
                return e => e.Id == 1;
            }
        }

    }
}
